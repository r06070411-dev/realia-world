<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>REALIA WORLD (Demo)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#05070f}
    #ui{
      position:fixed;left:12px;top:12px;z-index:10;display:flex;gap:8px;flex-wrap:wrap;
      font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;
    }
    .chip{
      background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.18);
      color:#fff;padding:8px 12px;border-radius:10px;font-size:13px;backdrop-filter:blur(10px)
    }
    .btn{cursor:pointer;user-select:none;background:rgba(129,86,255,.25);border:1px solid rgba(129,86,255,.55)}
    #hint{
      position:fixed;left:12px;bottom:12px;z-index:10;color:rgba(255,255,255,.9);
      font-size:13px;background:rgba(0,0,0,.25);padding:10px 12px;border-radius:10px;
      border:1px solid rgba(255,255,255,.12);max-width:min(540px,calc(100vw - 24px))
    }
    #stick{
      position:fixed;left:16px;bottom:80px;width:120px;height:120px;border-radius:50%;
      background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.18);
      display:none;z-index:10
    }
    #stick .knob{
      position:absolute;left:50%;top:50%;width:56px;height:56px;border-radius:50%;
      transform:translate(-50%,-50%);background:rgba(129,86,255,.6)
    }
    #jump{position:fixed;left:156px;bottom:98px;display:none;z-index:10}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <div class="chip"><b>REALIA WORLD</b> Demo</div>
    <div class="chip">FPS: <span id="fps">--</span></div>
    <div class="chip">POS: <span id="pos">--</span></div>
    <div class="chip btn" id="mode">操作: PC/スマホ自動</div>
  </div>

  <div id="stick"><div class="knob"></div></div>
  <div id="jump" class="chip btn">ジャンプ</div>

  <div id="hint">
    操作<br>
    PC: WASD移動 / マウスドラッグで視点 / 建物クリックで情報<br>
    スマホ: 画面ドラッグで視点 / 左スティックで移動 / タップで建物選択
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    // ===== 基本セットアップ =====
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05070f, 20, 200);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 500);
    camera.position.set(0, 2, 6);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // ライト
    scene.add(new THREE.AmbientLight(0x8899ff, 0.5));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // 地面
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(400,400),
      new THREE.MeshStandardMaterial({color:0x0b1022, roughness:1})
    );
    ground.rotation.x = -Math.PI/2;
    scene.add(ground);

    // グリッド都市（簡易オープンワールド）
    const buildings = [];
    const boxGeo = new THREE.BoxGeometry(1,1,1);
    for(let x=-20;x<=20;x+=3){
      for(let z=-20;z<=20;z+=3){
        if(Math.random()<0.25) continue;
        const h = 0.5 + Math.random()*6;
        const mat = new THREE.MeshStandardMaterial({
          color: new THREE.Color().setHSL(0.6+Math.random()*0.1,0.6,0.5),
          emissive:0x111122
        });
        const b = new THREE.Mesh(boxGeo, mat);
        b.scale.set(1, h, 1);
        b.position.set(x, h/2, z);
        b.userData = { name: `Building (${x},${z})`, height: h.toFixed(1) };
        scene.add(b);
        buildings.push(b);
      }
    }

    // ===== カメラ操作 =====
    let yaw = 0, pitch = 0;
    let isDown=false, px=0, py=0;

    function onDown(e){ isDown=true; px=e.clientX; py=e.clientY; }
    function onMove(e){
      if(!isDown) return;
      const dx = (e.clientX-px)*0.005;
      const dy = (e.clientY-py)*0.005;
      px=e.clientX; py=e.clientY;
      yaw -= dx; pitch = Math.max(-1.2, Math.min(1.2, pitch-dy));
    }
    function onUp(){ isDown=false; }

    addEventListener('pointerdown',onDown);
    addEventListener('pointermove',onMove);
    addEventListener('pointerup',onUp);

    // ===== 移動（PC） =====
    const key = {};
    addEventListener('keydown',e=>key[e.code]=true);
    addEventListener('keyup',e=>key[e.code]=false);

    // ===== スマホ仮想スティック =====
    const stick = document.getElementById('stick');
    const knob = stick.querySelector('.knob');
    const jumpBtn = document.getElementById('jump');
    let stickOn=false, sx=0, sy=0, sdx=0, sdy=0;

    function enableMobileUI(on){
      stick.style.display = on?'block':'none';
      jumpBtn.style.display = on?'block':'none';
    }
    const isTouch = 'ontouchstart' in window;
    enableMobileUI(isTouch);

    stick.addEventListener('pointerdown',e=>{
      stickOn=true; sx=e.clientX; sy=e.clientY;
      stick.setPointerCapture(e.pointerId);
    });
    addEventListener('pointermove',e=>{
      if(!stickOn) return;
      sdx = Math.max(-1, Math.min(1, (e.clientX-sx)/40));
      sdy = Math.max(-1, Math.min(1, (e.clientY-sy)/40));
      knob.style.transform = `translate(${sdx*28-50}%, ${sdy*28-50}%)`;
    });
    addEventListener('pointerup',()=>{ stickOn=false; sdx=0; sdy=0; knob.style.transform='translate(-50%,-50%)'; });

    // ===== クリック選択 =====
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    addEventListener('click',e=>{
      mouse.x = (e.clientX/innerWidth)*2-1;
      mouse.y = -(e.clientY/innerHeight)*2+1;
      ray.setFromCamera(mouse,camera);
      const hit = ray.intersectObjects(buildings);
      if(hit[0]){
        const u = hit[0].object.userData;
        alert(`${u.name}\n高さ: ${u.height}`);
      }
    });

    // ===== ループ =====
    let last=performance.now(), frames=0;
    function animate(){
      requestAnimationFrame(animate);

      // 移動ベクトル
      let vx=0, vz=0;
      if(key['KeyW']) vz-=1; if(key['KeyS']) vz+=1;
      if(key['KeyA']) vx-=1; if(key['KeyD']) vx+=1;
      if(isTouch){ vx+=sdx; vz+=sdy; }

      const speed = 0.08;
      const dir = new THREE.Vector3(
        Math.sin(yaw)*vz + Math.cos(yaw)*vx,
        0,
        Math.cos(yaw)*vz - Math.sin(yaw)*vx
      ).multiplyScalar(speed);

      camera.position.add(dir);
      camera.rotation.set(pitch, yaw, 0);

      // 表示
      frames++;
      const now=performance.now();
      if(now-last>1000){
        document.getElementById('fps').textContent = frames;
        frames=0; last=now;
      }
      document.getElementById('pos').textContent =
        `${camera.position.x.toFixed(1)}, ${camera.position.z.toFixed(1)}`;

      renderer.render(scene,camera);
    }
    animate();

    addEventListener('resize',()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  </script>
</body>
</html>
