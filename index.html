<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>REALIA WORLD - Neon City (Demo)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05070f; }
    canvas { display:block; }

    /* UI */
    #hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      display: flex; gap: 10px; flex-wrap: wrap;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
      color: #eaf0ff;
    }
    .pill{
      background: rgba(10,12,20,.55);
      border: 1px solid rgba(180,200,255,.18);
      border-radius: 14px;
      padding: 8px 12px;
      backdrop-filter: blur(10px);
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
    }
    .pill b{ font-weight: 800; letter-spacing: .3px; }
    .btn {
      cursor:pointer;
      border: 1px solid rgba(145,110,255,.5);
      background: rgba(145,110,255,.18);
      color: #f2edff;
      padding: 8px 12px;
      border-radius: 14px;
      user-select:none;
    }

    #hint {
      position: fixed; left: 12px; bottom: 12px; z-index: 10;
      max-width: min(720px, calc(100vw - 24px));
      background: rgba(10,12,20,.55);
      border: 1px solid rgba(180,200,255,.18);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      color:#eaf0ff;
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
      font-size: 13px;
      line-height: 1.45;
    }

    /* Mobile controls */
    #mobile {
      position: fixed; left: 0; right: 0; bottom: 90px; z-index: 12;
      display: none;
      pointer-events: none;
    }
    #stickBase {
      position: absolute; left: 18px; bottom: 18px;
      width: 140px; height: 140px;
      border-radius: 999px;
      background: rgba(10,12,20,.45);
      border: 1px solid rgba(180,200,255,.18);
      backdrop-filter: blur(10px);
      pointer-events: auto;
      touch-action: none;
    }
    #stickKnob {
      position: absolute; left: 50%; top: 50%;
      width: 64px; height: 64px;
      border-radius: 999px;
      transform: translate(-50%,-50%);
      background: radial-gradient(circle at 30% 30%, rgba(200,170,255,.95), rgba(120,80,255,.35));
      border: 1px solid rgba(200,170,255,.55);
    }
    #jumpBtn {
      position: absolute; right: 18px; bottom: 34px;
      pointer-events: auto;
      touch-action: manipulation;
      width: 132px;
      text-align:center;
    }

    @media (hover: none) and (pointer: coarse) {
      #mobile { display: block; }
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="pill"><b>REALIA WORLD</b> Neon City</div>
    <div class="pill">FPS: <span id="fps">--</span></div>
    <div class="pill">POS: <span id="pos">--</span></div>
    <div class="btn" id="resetBtn">リセット</div>
  </div>

  <div id="hint">
    操作<br/>
    PC: WASD移動 / マウスドラッグで視点 / クリックでポインタロック（任意） / Spaceジャンプ<br/>
    スマホ: 左スティック移動 / 画面ドラッグで視点 / ジャンプボタン
  </div>

  <div id="mobile">
    <div id="stickBase"><div id="stickKnob"></div></div>
    <div class="btn" id="jumpBtn">ジャンプ</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    // ========= Utils =========
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a,b,t)=>a+(b-a)*t;

    // ========= Renderer / Scene =========
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x070a18, 0.012);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1200);
    camera.position.set(0, 2.0, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(2, devicePixelRatio));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    document.body.appendChild(renderer.domElement);

    // ========= Lights =========
    const hemi = new THREE.HemisphereLight(0x6570ff, 0x060810, 0.55);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xb7c4ff, 0.65);
    dir.position.set(-8, 18, 8);
    scene.add(dir);

    // Neon accent lights
    const neonA = new THREE.PointLight(0x7b5cff, 1.2, 90, 2.0);
    neonA.position.set(0, 10, 0);
    scene.add(neonA);

    const neonB = new THREE.PointLight(0x00e5ff, 0.9, 80, 2.0);
    neonB.position.set(18, 8, -10);
    scene.add(neonB);

    // ========= Sky (gradient + stars) =========
    const skyGeo = new THREE.SphereGeometry(900, 32, 16);
    const skyMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: {
        top: { value: new THREE.Color(0x0a1230) },
        mid: { value: new THREE.Color(0x07102a) },
        bot: { value: new THREE.Color(0x04060f) }
      },
      vertexShader: `
        varying vec3 vPos;
        void main(){ vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
      `,
      fragmentShader: `
        varying vec3 vPos;
        uniform vec3 top; uniform vec3 mid; uniform vec3 bot;
        float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }
        void main(){
          float h = normalize(vPos).y;
          float t = smoothstep(-0.2, 0.9, h);
          vec3 col = mix(bot, mid, smoothstep(0.0, 0.55, t));
          col = mix(col, top, smoothstep(0.55, 1.0, t));
          // stars
          vec2 uv = normalize(vPos).xz * 0.5 + 0.5;
          float n = hash(floor(uv * 900.0));
          float s = step(0.9965, n) * (0.7 + 0.3*hash(floor(uv*1500.0)));
          col += vec3(1.0) * s;
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // ========= Ground / Roads =========
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(1200, 1200),
      new THREE.MeshStandardMaterial({ color: 0x05060a, roughness: 1.0, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // City blocks parameters
    const city = new THREE.Group();
    scene.add(city);

    // Road grid
    const roadMat = new THREE.MeshStandardMaterial({ color: 0x0b0e18, roughness: 0.9, metalness: 0.05 });
    const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x12182a, roughness: 0.85, metalness: 0.08 });
    const laneMat = new THREE.MeshBasicMaterial({ color: 0x3a4aa6, transparent:true, opacity:0.55 });

    function addRoad(x,z,w,l){
      const road = new THREE.Mesh(new THREE.BoxGeometry(w, 0.06, l), roadMat);
      road.position.set(x, 0.03, z);
      city.add(road);

      // Sidewalks
      const sw = new THREE.Mesh(new THREE.BoxGeometry(w+2.2, 0.08, l+2.2), sidewalkMat);
      sw.position.set(x, 0.02, z);
      city.add(sw);

      // Lane lines
      const lines = new THREE.Mesh(new THREE.PlaneGeometry(w*0.92, l*0.9), laneMat);
      lines.rotation.x = -Math.PI/2;
      lines.position.set(x, 0.061, z);
      city.add(lines);
    }

    // A long boulevard (like your image)
    addRoad(0, 0, 18, 360);
    // Cross streets
    for(let i=-4;i<=4;i++){
      addRoad(0, i*40, 80, 12);
    }

    // ========= Buildings (procedural) =========
    const bMat = new THREE.MeshStandardMaterial({ color: 0x1a2a55, roughness: 0.55, metalness: 0.35 });
    const bMat2= new THREE.MeshStandardMaterial({ color: 0x12203d, roughness: 0.6, metalness: 0.25 });
    const glowMat = new THREE.MeshBasicMaterial({ color: 0x6f5bff, transparent:true, opacity:0.55 });
    const glowMat2= new THREE.MeshBasicMaterial({ color: 0x00e5ff, transparent:true, opacity:0.35 });

    function addBuilding(x,z,w,d,h,alt=false){
      const mat = alt ? bMat2 : bMat;
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
      mesh.position.set(x, h/2, z);
      city.add(mesh);

      // Neon rim
      const rim = new THREE.Mesh(new THREE.BoxGeometry(w*1.01, 0.16, d*1.01), (Math.random()<0.5?glowMat:glowMat2));
      rim.position.set(x, h + 0.1, z);
      city.add(rim);

      // Simple "windows" as emissive planes
      const winCount = Math.floor(clamp(h/6, 2, 10));
      for(let i=0;i<winCount;i++){
        const y = lerp(1.2, h-1.2, (i+0.2)/winCount);
        const ww = w*0.82, hh = 0.6;
        const p = new THREE.Mesh(new THREE.PlaneGeometry(ww, hh),
          new THREE.MeshBasicMaterial({ color: (Math.random()<0.5?0x7b5cff:0x8ee9ff), transparent:true, opacity:0.16 })
        );
        p.position.set(x, y, z + d/2 + 0.01);
        city.add(p);

        const p2 = p.clone();
        p2.position.z = z - d/2 - 0.01;
        p2.rotation.y = Math.PI;
        city.add(p2);
      }
    }

    // Populate blocks along the boulevard
    function rand(a,b){ return a + Math.random()*(b-a); }

    for(let row=-4; row<=4; row++){
      const z0 = row*40;
      for(let side of [-1, 1]){
        for(let i=0;i<22;i++){
          const x = side*(rand(14, 44));
          const z = z0 + rand(-16, 16);
          const w = rand(4, 10);
          const d = rand(4, 10);
          const h = rand(8, 56) + (Math.abs(x) < 22 ? rand(10,30) : 0);
          addBuilding(x, z, w, d, h, Math.random()<0.45);
        }
      }
    }

    // Landmark tower (center distant)
    addBuilding(0, -160, 10, 10, 120, false);
    const spire = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.8, 40, 16), new THREE.MeshStandardMaterial({color:0xd7e3ff, metalness:0.85, roughness:0.25}));
    spire.position.set(0, 120+20, -160);
    city.add(spire);
    const spGlow = new THREE.PointLight(0x7b5cff, 1.6, 140, 2.2);
    spGlow.position.set(0, 120, -160);
    city.add(spGlow);

    // ========= Street lamps =========
    function addLamp(x,z){
      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.11, 4.2, 10),
        new THREE.MeshStandardMaterial({color:0x9fb3ff, metalness:0.8, roughness:0.35})
      );
      pole.position.set(x, 2.1, z);
      city.add(pole);

      const arm = new THREE.Mesh(
        new THREE.BoxGeometry(1.6, 0.08, 0.08),
        new THREE.MeshStandardMaterial({color:0xaec0ff, metalness:0.8, roughness:0.3})
      );
      arm.position.set(x+0.8, 3.8, z);
      city.add(arm);

      const lamp = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.14, 0.25, 4, 10),
        new THREE.MeshBasicMaterial({color:0xfff6d6})
      );
      lamp.position.set(x+1.45, 3.8, z);
      lamp.rotation.z = Math.PI/2;
      city.add(lamp);

      const light = new THREE.PointLight(0xfff1c4, 1.1, 18, 2.0);
      light.position.set(x+1.45, 3.6, z);
      city.add(light);
    }

    for(let i=-7;i<=7;i++){
      const z = i*22;
      addLamp(-8.2, z);
      addLamp( 8.2, z);
    }

    // ========= Billboards =========
    function makeBillboardTexture(text, colorA, colorB){
      const c = document.createElement('canvas');
      c.width = 512; c.height = 256;
      const g = c.getContext('2d');
      // background gradient
      const grad = g.createLinearGradient(0,0,512,256);
      grad.addColorStop(0, colorA);
      grad.addColorStop(1, colorB);
      g.fillStyle = grad;
      g.fillRect(0,0,512,256);
      // glow frame
      g.strokeStyle = 'rgba(255,255,255,0.35)';
      g.lineWidth = 6;
      g.strokeRect(8,8,496,240);
      // text
      g.fillStyle = 'rgba(10,12,20,0.35)';
      g.fillRect(30,70,452,120);
      g.fillStyle = 'rgba(255,255,255,0.92)';
      g.font = 'bold 46px sans-serif';
      g.fillText(text, 42, 145);
      g.font = '20px sans-serif';
      g.fillStyle = 'rgba(255,255,255,0.80)';
      g.fillText('REALIA / CITY NETWORK', 44, 190);
      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = 4;
      return tex;
    }

    function addBillboard(x,z,rot=0,txt="REALIA"){
      const tex = makeBillboardTexture(txt, '#6f5bff', '#00e5ff');
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true });
      const panel = new THREE.Mesh(new THREE.PlaneGeometry(4.8, 2.4), mat);
      panel.position.set(x, 2.4, z);
      panel.rotation.y = rot;
      city.add(panel);

      const back = panel.clone();
      back.rotation.y += Math.PI;
      city.add(back);

      const glow = new THREE.PointLight(0x7b5cff, 0.9, 20, 2.2);
      glow.position.set(x, 2.4, z);
      city.add(glow);
    }

    addBillboard(-10.5, -10, Math.PI/2, "SHOP");
    addBillboard( 10.5,  18, -Math.PI/2, "OFFICE");
    addBillboard(-10.5,  46, Math.PI/2, "EVENT");
    addBillboard( 10.5, -54, -Math.PI/2, "VR CITY");

    // ========= Player / Controls (simple FPS-like) =========
    const player = {
      pos: new THREE.Vector3(0, 1.8, 6),
      vel: new THREE.Vector3(0, 0, 0),
      yaw: 0,
      pitch: 0,
      grounded: true
    };

    const keys = { w:false,a:false,s:false,d:false, space:false };
    addEventListener('keydown', (e)=>{
      if(e.code === 'KeyW') keys.w=true;
      if(e.code === 'KeyA') keys.a=true;
      if(e.code === 'KeyS') keys.s=true;
      if(e.code === 'KeyD') keys.d=true;
      if(e.code === 'Space') keys.space=true;
    });
    addEventListener('keyup', (e)=>{
      if(e.code === 'KeyW') keys.w=false;
      if(e.code === 'KeyA') keys.a=false;
      if(e.code === 'KeyS') keys.s=false;
      if(e.code === 'KeyD') keys.d=false;
      if(e.code === 'Space') keys.space=false;
    });

    // Mouse/touch look
    let dragging = false;
    let lastX=0,lastY=0;

    function lookDelta(dx, dy){
      const sens = 0.0032;
      player.yaw   -= dx * sens;
      player.pitch -= dy * sens;
      player.pitch = clamp(player.pitch, -1.2, 1.2);
    }

    renderer.domElement.addEventListener('pointerdown', (e)=>{
      dragging = true;
      lastX = e.clientX; lastY = e.clientY;
    }, {passive:true});
    addEventListener('pointerup', ()=> dragging=false, {passive:true});
    addEventListener('pointermove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      lookDelta(dx, dy);
    }, {passive:true});

    // Optional: click to pointer lock (PC)
    renderer.domElement.addEventListener('click', ()=>{
      if (matchMedia('(hover: hover)').matches) {
        renderer.domElement.requestPointerLock?.();
      }
    });
    document.addEventListener('mousemove', (e)=>{
      if(document.pointerLockElement === renderer.domElement){
        lookDelta(e.movementX, e.movementY);
      }
    });

    // Mobile stick
    const stickBase = document.getElementById('stickBase');
    const stickKnob = document.getElementById('stickKnob');
    const jumpBtn = document.getElementById('jumpBtn');

    let stick = { active:false, x:0, y:0, id:null };

    function setKnob(x,y){
      stickKnob.style.transform = `translate(${x}px, ${y}px) translate(-50%,-50%)`;
    }

    stickBase.addEventListener('pointerdown', (e)=>{
      stick.active = true; stick.id = e.pointerId;
      stickBase.setPointerCapture(e.pointerId);
      stick.x = 0; stick.y = 0;
      setKnob(0,0);
    });
    stickBase.addEventListener('pointermove', (e)=>{
      if(!stick.active || e.pointerId !== stick.id) return;
      const rect = stickBase.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const dx = e.clientX - cx;
      const dy = e.clientY - cy;
      const maxR = rect.width*0.35;
      const nx = clamp(dx, -maxR, maxR);
      const ny = clamp(dy, -maxR, maxR);
      stick.x = nx / maxR;
      stick.y = ny / maxR;
      setKnob(nx, ny);
    });
    stickBase.addEventListener('pointerup', (e)=>{
      if(e.pointerId !== stick.id) return;
      stick.active = false; stick.id = null;
      stick.x = 0; stick.y = 0;
      setKnob(0,0);
    });

    jumpBtn.addEventListener('click', ()=>{ keys.space = true; setTimeout(()=>keys.space=false, 80); });

    // Reset button
    document.getElementById('resetBtn').addEventListener('click', ()=>{
      player.pos.set(0, 1.8, 6);
      player.vel.set(0,0,0);
      player.yaw = 0; player.pitch = 0;
    });

    // ========= Simple collisions with ground only =========
    const GRAV = 18.0;

    // ========= Animate =========
    let lastT = performance.now();
    let fpsAcc=0, fpsCnt=0, fpsShow=0;

    function animate(){
      requestAnimationFrame(animate);
      const t = performance.now();
      const dt = Math.min(0.033, (t-lastT)/1000);
      lastT = t;

      // Movement input
      let ix = 0, iz = 0;
      if(keys.w) iz -= 1;
      if(keys.s) iz += 1;
      if(keys.a) ix -= 1;
      if(keys.d) ix += 1;

      // Mobile stick adds
      ix += stick.x;
      iz += stick.y;

      const len = Math.hypot(ix, iz);
      if(len > 1e-3){ ix/=len; iz/=len; }

      const speed = 8.0;
      const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
      const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));

      const wish = new THREE.Vector3()
        .addScaledVector(right, ix)
        .addScaledVector(forward, iz);

      player.vel.x = wish.x * speed;
      player.vel.z = wish.z * speed;

      // Gravity / jump
      player.vel.y -= GRAV * dt;
      if(player.grounded && keys.space){
        player.vel.y = 7.6;
        player.grounded = false;
      }

      player.pos.addScaledVector(player.vel, dt);

      // Ground collision
      if(player.pos.y < 1.8){
        player.pos.y = 1.8;
        player.vel.y = 0;
        player.grounded = true;
      }

      // Camera
      camera.position.copy(player.pos);
      camera.rotation.order = "YXZ";
      camera.rotation.y = player.yaw;
      camera.rotation.x = player.pitch;

      // Subtle city pulse
      neonA.intensity = 1.0 + 0.25*Math.sin(t*0.0012);
      neonB.intensity = 0.75 + 0.2*Math.cos(t*0.0010);

      renderer.render(scene, camera);

      // HUD
      fpsAcc += 1/dt; fpsCnt++;
      if(fpsCnt >= 12){
        fpsShow = fpsAcc / fpsCnt;
        fpsAcc = 0; fpsCnt = 0;
        document.getElementById('fps').textContent = fpsShow.toFixed(0);
      }
      document.getElementById('pos').textContent =
        `${player.pos.x.toFixed(1)}, ${player.pos.y.toFixed(1)}, ${player.pos.z.toFixed(1)}`;
    }
    animate();

    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
